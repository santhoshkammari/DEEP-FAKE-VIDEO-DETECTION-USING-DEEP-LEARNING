# -*- coding: utf-8 -*-
"""video-image.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1heMvFPXVYDeMrikSz5xRN8FCIXaTqJkc
"""

!pip install face-recognition

import face_recognition

# Importing all necessary libraries
import cv2
import os

# Read the video from specified path
cam = cv2.VideoCapture("/content/drive/MyDrive/IIITM/BTP/SAMPLE-VIDEO/aagfhgtpmv.mp4")
!pwd

cd /content/drive/MyDrive/IIITM/BTP

!pwd

def convertToRGB(image):
    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

haar_cascade_face = cv2.CascadeClassifier("/content/drive/MyDrive/IIITM/BTP/modelfiles/haarcascade_frontalface_default.xml")

def detect_faces(cascade, test_image, scaleFactor = 1.10):
    # create a copy of the image to prevent any changes to the original one.
    image_copy = test_image.copy()
    
    #convert the test image to gray scale as opencv face detector expects gray images
    gray_image = cv2.cvtColor(image_copy, cv2.COLOR_BGR2GRAY)
    
    # Applying the haar classifier to detect faces
    faces_rect = cascade.detectMultiScale(gray_image,scaleFactor,minNeighbors=7)
    
    for (x, y, w, h) in faces_rect:
        cv2.rectangle(image_copy, (x, y), (x+w, y+h), (0, 255, 0), 15)
        
    return faces_rect,image_copy

def face_found(path):
  faces=face_recognition.load_image_file(path)
  f_loc=face_recognition.face_locations(faces)
  return len(f_loc)

try:
	
	# creating a folder named data
	if not os.path.exists('data'):
		os.makedirs('data')

# if not created then raise error
except OSError:
	print ('Error: Creating directory of data')

# frame
currentframe = 0
i=0
sec=0
frame_rrate=0.25
while(True):

	# reading from frame
	cam.set(cv2.CAP_PROP_POS_MSEC,sec*1000)
	ret,frame = cam.read()
	sec=sec+frame_rrate
	sec=round(sec,2)

	if ret:
		# if video is still left continue creating images
		name = './data/frame' + str(currentframe) + '.jpg'
		print ('Creating...' + name)

		# writing the extracted images
		cv2.imwrite(name, frame)
		i+=1
		image_count="/content/drive/MyDrive/IIITM/BTP/data/frame"+str(currentframe)+".jpg"
		if not face_found(image_count):
		  print ('hai')
		  os.remove(image_count)
		# increasing counter so that it will
		# show how many frames are created
		currentframe += 1
	else:
		break

# Release all space and windows once done
cam.release()
cv2.destroyAllWindows()

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

fig=plt.figure()
from random import randint
startstring="/content/drive/MyDrive/IIITM/BTP/data/frame"
endingstring=".jpg"
for i in range(36):
  img=startstring+str(i)+endingstring
  if os.path.exists(img):
    root=mpimg.imread(img)
    plt.subplot(5,5,i+1)
    plt.imshow(root)
plt.show()

d=[]
for files in os.walk('/content/drive/MyDrive/IIITM/BTP/data',topdown=True):
 d.append(files)

t1=d[0][2]



plt.imshow(mpimg.imread("/content/drive/MyDrive/IIITM/BTP/data/frame8.jpg"))

print(face_found("/content/drive/MyDrive/IIITM/BTP/data/frame8.jpg"))

plt.imshow(mpimg.imread("/content/download1.png"))

print(face_found("/content/download1.png"))

startstring="/content/drive/MyDrive/IIITM/BTP/data/"
endingstring=".jpg"
count_faces=0
for i in t1:
  img=startstring+i
  print(img)
  given_image = face_recognition.load_image_file(img)
  face_locations = face_recognition.face_locations(given_image)
  if len(face_locations)>=1:
    count_faces+=1
print(count_faces)

startstring="/content/drive/MyDrive/IIITM/BTP/data/frame"
endingstring=".jpg"
count_faces=0
for i in range(20):
  img=startstring+str(i)+endingstring
  print(img)
  given_image = face_recognition.load_image_file(img)
  face_locations = face_recognition.face_locations(given_image)
  if len(face_locations)>=1:
    count_faces+=1
print(count_faces)